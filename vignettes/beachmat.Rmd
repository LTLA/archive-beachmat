<!--
%\VignetteIndexEntry{A C++ API for R matrix objects}
%\VignettePackage{BiocStyle}
%\VignetteEngine{knitr::knitr}
-->

```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
```

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown()
```

# A common C++ API for all types of R matrices
Package: `r Rpackage("beachmat")` <br />
Author: Aaron Lun (alun@wehi.edu.au) <br />
Compilation date: `r Sys.Date()`

# Introduction

The _beachmat_ package provides a C++ API for handling a variety of R matrix types.
The aim is to abstract away the specific type of matrix object when writing C++ extensions, thus simplifying the processing of data stored in those objects.
Currently, the API supports double-precision, integer, logical and character matrices.
Supported classes include base `matrix` objects, a number of classes from the `r CRANpkg("Matrix")` package, and disk-backed matrices from the `r CRANpkg("HDF5Array")` package.

# Linking to the package

## Prerequisites

The _beachmat_ package currently has several dependencies:

- The compiler should support the C++11 standard.
- `r CRANpkg("Rcpp")` should be installed.
- To support `HDF5Matrix` objects, the system should have the HDF5 libraries installed (see https://support.hdfgroup.org/HDF5/).
Currently, we are not particularly smart about detecting non-default installation locations - this should hopefully be rectified in the future.
If the HDF5 libraries are not installed, _beachmat_ can still be used but will not support `HDF5Matrix` access.

Most of the following instructions are ripped from the `r Biocpkg("Rhtslib")` vignette.

## Link to the library

To link successfully to the _beachmat_ library, a package must include *both* a `src/Makevars.win` *and* `src/Makevars` file.  

**Note**: the contents of `src/Makevars.win` and `src/Makevars` are almost identical, but not quite. 
Be careful of the differences.

Create a `src/Makevars.win` file with the following lines:

```
BEACHLIB_LIBS=$(shell echo 'beachmat::pkgconfig("PKG_LIBS")'|\
    "${R_HOME}/bin/R" --vanilla --slave)
PKG_LIBS=$(BEACHLIB_LIBS)
```

... and a `src/Makevars` file with the following lines:

```
BEACHLIB_LIBS=`echo 'beachmat::pkgconfig("PKG_LIBS")'|\
    "${R_HOME}/bin/R" --vanilla --slave`
PKG_LIBS=$(BEACHLIB_LIBS)
```

The statement for each platfrom modifies the `$PKG_LIBS` variable. 
If your package needs to add to the `$PKG_LIBS` variable, do so by adding to the `PKG_LIBS=$(RHTSLIB_LIBS)` line.
For example:

```
PKG_LIBS=$(RHTSLIB_LIBS) -L/path/to/foolib -lfoo
```

## Find headers

In order for the C/C++ compiler to find the _beachmat_ package headers during installation, add `beachmat` and `Rcpp` to the `LinkingTo` field of the `DESCRIPTION` file:

```
LinkingTo: Rcpp, beachmat
``` 
    
In C or C++ code files, use standard techniques, e.g., `#include "beachmat/numeric_matrix.h"` (see below for more details). 
Header files are available for perusal at the following location (enter in an R session):

```{R headers}
system.file(package="beachmat", "include")
```

## Finishing up

You need to tell the build system to use C++11, by modifying the `SystemRequirements` field of the `DESCRIPTION` file:

```
SystemRequirements: C++11
```

You also need to ensure that `r CRANpkg("Rcpp")` is initialized when your package is loaded.
This requires addition of `Rcpp` to the `Imports` field of the `DESCRIPTION` file:

```
Imports: Rcpp
```

... and a corresponding  `importFrom` specification in the `NAMESPACE` file:

```
importFrom(Rcpp, sourceRcpp)
```
 
(The exact function to be imported doesn't matter, as long as the namespace is loaded.)
Check out the `r CRANpkg("Rcpp")` documentation for more details.

# Overview of the API

## An example with a numeric matrix

We demonstrate the use of the API for numeric matrices.
First, we include the relevant header file:

```
#include "beachmat/numeric_matrix.h"
```

A double-precision matrix object `dmat` is handled in C++ by passing the `SEXP` struct from `.Call` to `create_numeric_matrix`:

```
std::shared_dptr<beachmat::numeric_matrix> dptr = beachmat::create_numeric_matrix(dmat);
```

This creates a shared pointer that points to an object of the `numeric_matrix` virtual class.
The exact class depends on the type of matrix in `dmat`, though the behaviour of the user-level functions are not affected by this detail.

The available methods for this object are:

- `dptr->get_nrow()` returns an integer number of rows (`nrow`).
- `dptr->get_ncol()` returns an integer number of columns (`ncol`).
- `dptr->get_col(c, X)` takes a `Rcpp::NumericVector::iterator` (`X`) and fills it with values at column `c`.
There should be at least `nrow` accessible elements, i.e., `*X` and `*(X+nrow-1)` should be valid entries.
No value is returned by this method.
- `dptr->get_row(r, X)` takes a `Rcpp::NumericVector::iterator` (`X`) and fills it with values at row `r`.
There should be at least `ncol` accessible elements, i.e., `*X` and `*(X+ncol-1)` should be valid entries.
No value is returned by this method.
- `dptr->get(r, c)` returns a double at matrix entry `(r, c)`.

In all cases, `r` and `c` should be non-negative integers in `[0, nrow)` and `[0, ncol)` respectively.
Zero-based indexing is assumed for both `r` and `c`, as is standard for most C/C++ applications.

## Other matrix types

Logical, integer and character matrices are also supported, by including the following header files:

```
#include "beachmat/logical_matrix.h"
#include "beachmat/integer_matrix.h"
#include "beachmat/character_matrix.h"
```

The creation function changes correspondingly, for logical matrix `lmat`, integer matrix `imat` and character matrix `cmat`:

```
std::shared_ptr<beachmat::logical_matrix> lptr=beachmat::create_logical_matrix(lmat);
std::shared_ptr<beachmat::integer_matrix> iptr=beachmat::create_integer_matrix(imat);
std::shared_ptr<beachmat::character_matrix> cptr=beachmat::create_character_matrix(cmat);
```

For integer and logical matrices, `X` should be of type `Rcpp::IntegerVector::iterator` and `Rcpp::LogicalVector::iterator`, respectively, and `get` will return an integer.
For character matrices, `X` should be of type `Rcpp::StringVector::iterator`, and `get` will return a `Rcpp::String`.

## Important developer information 

- R stores dimensions as integers rather than as `size_t`, so we simply follow suit when calling `get_nrow` and `get_ncol`.
- In theory, greater efficiency could be obtained when calling `get_col` on column-major base matrices.
Specifically, a pointer to the column could be directly returned rather than copying the data to a new `Vector` object. 
However, other matrix classes do not store data in the same manner; if a pointer is to be returned, it would have to be to some internal storage.
This would be dangerous as the values in the internal storage will change upon repeated calls to `get_col`.
Filling a user-supplied array is more intuitive as it is obvious that the array will change when `get_col` is called again.
- The API is not thread-safe for multiple shared pointers to the same `*_matrix` instance.
Some intermediate constructs are cached for greater efficiency, and simultaneous calls will cause race conditions. 
Users should instead create new shared pointers for use in each thread, by copying the `*_matrix` instance via `std::make_shared`.
This is fairly cheap as the matrix data itself is not copied.
- When accessing `character_matrix` data, the `Rcpp::String` class is used as it provides a convenient wrapper around the underlying `CHARSXP`. 
This ensures that the string is stored in R's global cache and is suitably protected against garbage collection. 
- The API will happily throw exceptions of the `std::exception` class, containing an informative error message.
These should be caught and handled gracefully by the end-user code, otherwise a segmentation fault will probably occur.
See the error-handling mechanism in `r CRANpkg("Rcpp")` for how to deal with these exceptions.

<!--
Advanced comments:

- If any class has pointers to SEXP data, the data that each pointer points to should be contained within a RObject that is also a member of the class. 
This ensures that the data is PROTECTed for the lifetime of the class instance. 
Otherwise, one could imagine a situation where the class is instantiated from an RObject; the RObject is destroyed; and garbage collection occurs.
This would invalidate the pointers in the class instance.
- The two major templated values are 'T' and 'V'; 'T' for the return type of 'get', 'V' for the Rcpp::Vector class used for internal storage and iterators.
Any combination of template arguments is permitted where an indexed of 'V' can be successfully converted to type 'T'.
- It would be nice to allow the fill_* methods to take any random access iterator; however, virtual methods cannot be templated.
We could add a template argument to the entire class, but this would only allow it to take either a random access iterator or a pointer (not both).
Overloading seems like the best approach, but would be a pain if I have to rewrite every fill_* method.
-->

# Supported matrix types

The following matrix classes are supported:

- numeric: `matrix`, `dgeMatrix`, `dgCMatrix`, `dspMatrix`, `HDF5Matrix`
- integer: `matrix`, `HDF5Matrix`
- logical: `matrix`, `lgeMatrix`, `lgCMatrix`, `lspMatrix`, `HDF5Matrix`
- character: `matrix`, `HDF5Matrix`

Additional classes can be added on a need-to-use basis.
As a general rule, if a matrix-like object can be stored in a `SummarizedExperiment` class (from the `r Biocpkg("SummarizedExperiment")` package), the API should be able to handle it.
Please contact the maintainers if you have a class that you would like to see supported.

# Session information

```{r}
sessionInfo()
```
