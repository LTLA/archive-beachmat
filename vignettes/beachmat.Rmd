<!--
%\VignetteIndexEntry{A C++ API for R matrix objects}
%\VignettePackage{BiocStyle}
%\VignetteEngine{knitr::knitr}
-->

```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
```

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown()
```

# A common C++ API for all types of R matrices
Package: `r Rpackage("beachmat")` <br />
Author: Aaron Lun (alun@wehi.edu.au) <br />
Compilation date: `r Sys.Date()`

# Introduction

The _beachmat_ package provides a C++ API for handling a variety of R matrix types.
The aim is to abstract away the specific type of matrix object when writing C++ extensions, thus simplifying the processing of data stored in those objects.
Currently, the API supports double-precision, integer, logical and character matrices.
Supported classes include base `matrix` objects, a number of classes from the `r CRANpkg("Matrix")` package, and disk-backed matrices from the `r CRANpkg("HDF5Array")` package.

# Linking to the package

## Prerequisites

The _beachmat_ package currently has several dependencies:

- The compiler should support the C++11 standard.
- `r CRANpkg("Rcpp")` should be installed.
- To support `HDF5Matrix` objects, the system should have the HDF5 libraries installed (see https://support.hdfgroup.org/HDF5/).
Currently, we are not particularly smart about detecting non-default installation locations - this should hopefully be rectified in the future.
If the HDF5 libraries are not installed, _beachmat_ can still be used but will not support `HDF5Matrix` access.

Most of the following instructions are ripped from the `r Biocpkg("Rhtslib")` vignette.

## Link to the library

To link successfully to the _beachmat_ library, a package must include *both* a `src/Makevars.win` *and* `src/Makevars` file.  

**Note**: the contents of `src/Makevars.win` and `src/Makevars` are almost identical, but not quite. 
Be careful of the differences.

Create a `src/Makevars.win` file with the following lines:

```
BEACHMAT_LIBS=$(shell echo 'beachmat::pkgconfig("PKG_LIBS")'|\
    "${R_HOME}/bin/R" --vanilla --slave)
PKG_LIBS=$(BEACHMAT_LIBS)
```

... and a `src/Makevars` file with the following lines:

```
BEACHMAT_LIBS=`echo 'beachmat::pkgconfig("PKG_LIBS")'|\
    "${R_HOME}/bin/R" --vanilla --slave`
PKG_LIBS=$(BEACHMAT_LIBS)
```

The statement for each platfrom modifies the `$PKG_LIBS` variable. 
If your package needs to add to the `$PKG_LIBS` variable, do so by adding to the `PKG_LIBS=$(BEACHMAT_LIBS)` line.
For example:

```
PKG_LIBS=$(BEACHMAT_LIBS) -L/path/to/foolib -lfoo
```

## Find headers

In order for the C/C++ compiler to find the _beachmat_ package headers during installation, add the following to the `LinkingTo` field of the `DESCRIPTION` file:

```
LinkingTo: Rcpp, Rhdf5lib, beachmat
``` 
    
In C or C++ code files, use standard techniques, e.g., `#include "beachmat/numeric_matrix.h"` (see below for more details). 
Header files are available for perusal at the following location (enter in an R session):

```{R headers}
system.file(package="beachmat", "include")
```

## Finishing up

You need to tell the build system to use C++11, by modifying the `SystemRequirements` field of the `DESCRIPTION` file:

```
SystemRequirements: C++11
```

You also need to ensure that `r CRANpkg("Rcpp")` is initialized when your package is loaded.
This requires addition of `Rcpp` to the `Imports` field of the `DESCRIPTION` file:

```
Imports: Rcpp
```

... and a corresponding  `importFrom` specification in the `NAMESPACE` file:

```
importFrom(Rcpp, sourceCpp)
```
 
(The exact function to be imported doesn't matter, as long as the namespace is loaded.)
Check out the `r CRANpkg("Rcpp")` documentation for more details.

If you intend to accept instances of `r CRANpkg("Matrix")`, `r Biocpkg("HDF5Array")` or `r Biocpkg("DelayedArray")` classes, these packages should be listed in the `Suggests` field, if they are not already in `Imports` or `Depends`:

```
Suggests: Matrix, HDF5Array, DelayedArray
```

# Overview of the API (input)

## An example with a numeric matrix

We demonstrate the use of the API for numeric matrices.
First, we include the relevant header file:

```
#include "beachmat/numeric_matrix.h"
```

A double-precision matrix object `dmat` is handled in C++ by passing the `SEXP` struct from `.Call` to `create_numeric_matrix`:

```
std::unique_ptr<beachmat::numeric_matrix> dptr = beachmat::create_numeric_matrix(dmat);
```

This creates a unique pointer that points to an object of the `numeric_matrix` virtual class.
The exact class depends on the type of matrix in `dmat`, though the behaviour of the user-level functions are not affected by this detail.

The available methods for this object are:

- `dptr->get_nrow()` returns the number of rows (`nrow`) as a `size_t`.
- `dptr->get_ncol()` returns the number of columns (`ncol`) as a `size_t`.
- `dptr->get_col(c, X)` takes a `Rcpp::NumericVector::iterator` (`X`) and fills it with values at column `c`.
There should be at least `nrow` accessible elements, i.e., `*X` and `*(X+nrow-1)` should be valid entries.
No value is returned by this method.
- `dptr->get_col(c, X, rstart, rend)` takes a `Rcpp::NumericVector::iterator` (`X`) and fills it with values at column `c` from row `rstart` to `rend-1`.
There should be at least `rend-rstart` accessible elements, i.e., `*X` and `*(X+rend-rstart-1)` should be valid entries.
No value is returned by this method.
- `dptr->get_row(r, X)` takes a `Rcpp::NumericVector::iterator` (`X`) and fills it with values at row `r`.
There should be at least `ncol` accessible elements, i.e., `*X` and `*(X+ncol-1)` should be valid entries.
No value is returned by this method.
- `dptr->get_row(r, X, cstart, cend)` takes a `Rcpp::NumericVector::iterator` (`X`) and fills it with values at row `r` from column `cstart` to `cend-1`.
There should be at least `cend-cstart` accessible elements, i.e., `*X` and `*(X+cend-cstart-1)` should be valid entries.
No value is returned by this method.
- `dptr->get(r, c)` returns a double at matrix entry `(r, c)`.
- `dptr->clone()` returns a unique pointer to a `numeric_matrix` instance of the same type as that pointed to by `dptr`.

In all cases, `r` and `c` should be non-negative integers (specificaly `size_t`) in `[0, nrow)` and `[0, ncol)` respectively.
Zero-based indexing is assumed for both `r` and `c`, as is standard for most C/C++ applications.
Similar rules apply to `rstart` and `rend`, which should be in `[0, nrow]`; and to `cstart` and `cend`, which should be in `[0, ncol]`.

## Other matrix types

Logical, integer and character matrices can be handled by including the following header files:

```
#include "beachmat/logical_matrix.h"
#include "beachmat/integer_matrix.h"
#include "beachmat/character_matrix.h"
```

The dispatch function changes correspondingly, for logical matrix `lmat`, integer matrix `imat` and character matrix `cmat`:

```
std::unique_ptr<beachmat::logical_matrix> lptr=beachmat::create_logical_matrix(lmat);
std::unique_ptr<beachmat::integer_matrix> iptr=beachmat::create_integer_matrix(imat);
std::unique_ptr<beachmat::character_matrix> cptr=beachmat::create_character_matrix(cmat);
```

Equivalent methods are available for all matrix types with appropriate changes in type.
For integer and logical matrices, `X` should be of type `Rcpp::IntegerVector::iterator` and `Rcpp::LogicalVector::iterator`, respectively, and `get` will return an integer.
For character matrices, `X` should be of type `Rcpp::StringVector::iterator`, and `get` will return a `Rcpp::String`.

The following matrix classes are supported:

- numeric: `matrix`, `dgeMatrix`, `dgCMatrix`, `dspMatrix`, `HDF5Matrix`, `DelayedMatrix`
- integer: `matrix`, `HDF5Matrix`, `DelayedMatrix`
- logical: `matrix`, `lgeMatrix`, `lgCMatrix`, `lspMatrix`, `HDF5Matrix`, `DelayedMatrix`
- character: `matrix`, `HDF5Matrix`, `DelayedMatrix`

Additional classes can be added on a need-to-use basis.
As a general rule, if a matrix-like object can be stored in a `SummarizedExperiment` class (from the `r Biocpkg("SummarizedExperiment")` package), the API should be able to handle it.
Please contact the maintainers if you have a class that you would like to see supported.

## Important developer information 

- In theory, greater efficiency could be obtained when calling `get_col` on column-major base matrices.
Specifically, a pointer to the column could be directly returned rather than copying the data to a new `Vector` object. 
However, other matrix classes do not store data in the same manner; if a pointer is to be returned, it would have to be to some internal storage.
This would be dangerous as the values in the internal storage will change upon repeated calls to `get_col`.
Filling a user-supplied array is more intuitive as it is obvious that the array will change when `get_col` is called again.
- The API is not thread-safe for simultaneous calls to the `get` methods from different threads.
Some methods use cached class members for greater efficiency, and simultaneous calls will cause race conditions. 
It is the responsibility of the calling function to lock (and unlock) access to a single `*_matrix` object across threads.
Alternatively, the `clone` method can be called to generate a unique pointer to a _new_ `*_matrix` instance, which can be used concurrently in another thread.
This is fairly cheap as the underlying matrix data are not copied.
- When accessing `character_matrix` data, the `Rcpp::String` class is used as it provides a convenient wrapper around the underlying `CHARSXP`. 
This ensures that the string is stored in R's global cache and is suitably protected against garbage collection. 
- `DelayedMatrix` objects are automatically realized to `HDF5Matrix` objects via the `realize` method in the `r Biocpkg("DelayedArray")` package.
If the realized matrix is to be reused, it may be more efficient to perform the realization in R and pass the `HDF5Matrix` to `.Call`.
- The API will happily throw exceptions of the `std::exception` class, containing an informative error message.
These should be caught and handled gracefully by the end-user code, otherwise a segmentation fault will probably occur.
See the error-handling mechanism in `r CRANpkg("Rcpp")` for how to deal with these exceptions.

<!--
Advanced comments:

- If any class has pointers to SEXP data, the data that each pointer points to should be contained within a RObject that is also a member of the class. 
This ensures that the data is PROTECTed for the lifetime of the class instance. 
Otherwise, one could imagine a situation where the class is instantiated from an RObject; the RObject is destroyed; and garbage collection occurs.
This would invalidate the pointers in the class instance.
- The two major templated values are 'T' and 'V'; 'T' for the return type of 'get', 'V' for the Rcpp::Vector class used for internal storage and iterators.
Any combination of template arguments is permitted where an indexed of 'V' can be successfully converted to type 'T'.
- It would be nice to allow the fill_* methods to take any random access iterator; however, virtual methods cannot be templated.
We could add a template argument to the entire class, but this would only allow it to take either a random access iterator or a pointer (not both).
Overloading seems like the best approach, but would be a pain if I have to rewrite every fill_* method.
-->

# Overview of the API (output)

## An example with a numeric matrix

Two types of output matrices are supported - simple `matrix` and `HDF5Matrix` objects.
A simple numeric output matrix with `nrow` rows and `ncol` columns is created by:

```
std::unique_ptr<numeric_output> odmat=beachmat::create_numeric_output(nrow, ncol);
```

A numeric `HDF5Matrix` output matrix is created by setting the last argument (`basic`) to `false`:

```
std::unique_ptr<numeric_output> odmat=beachmat::create_numeric_output(nrow, ncol, false);
```

The function is also overloaded so that it can choose the type of output to match an input type.
For example, if I have a matrix object `dmat`, the output type can be matched to the input type with:

```
std::unique_ptr<numeric_output> odmat=beachmat::create_numeric_output(nrow, ncol, dmat, false);
```

Here, the last argument (`simplify`) indicates whether non-`matrix` input objects should be "simplified" to a `matrix` output object.
If `false`, a `HDF5Matrix` output object will be returned instead.

All of the methods described for `numeric_matrix` objects are also available for a `numeric_output` matrix.
In addition, several methods are available for storing data:

- `dptr->fill_col(c, X)` fills column `c` with elements pointed to by a `Rcpp::NumericVector::iterator` object (`X`).
There should be at least `nrow` accessible elements, i.e., `*X` and `*(X+nrow-1)` should be valid entries.
No value is returned by this method.
- `dptr->fill_col(c, X, rstart, rend)` fills column `c` from row `rstart` to `rend-1`, using the elements pointed to by a `Rcpp::NumericVector::iterator` object (`X`).
There should be at least `rend-rstart` accessible elements, i.e., `*X` and `*(X+rend-rstart-1)` should be valid entries.
No value is returned by this method.
- `dptr->fill_row(r, X)` fills row `r` with elements pointed to by a `Rcpp::NumericVector::iterator` object (`X`).
There should be at least `ncol` accessible elements, i.e., `*X` and `*(X+ncol-1)` should be valid entries.
No value is returned by this method.
- `dptr->fill_row(r, X, cstart, cend)` fills row `r` from column `cstart` to `cend-1`, with elements pointed to by a `Rcpp::NumericVector::iterator` object (`X`).
There should be at least `cend-cstart` accessible elements, i.e., `*X` and `*(X+cend-cstart-1)` should be valid entries.
No value is returned by this method.
- `dptr->fill(r, c, Y)` fills the matrix entry `(r, c)` with the double `Y`.

The allowable range of `r`, `c`, `rstart`, `rend`, `cstart` and `cend` is the same as previously described.

## Other matrix types

Logical and integer output matrices are supported by changing the types in the creator function (and its variants):

```
std::unique_ptr<integer_output> oimat=beachmat::create_integer_output(nrow, ncol);
std::unique_ptr<logical_output> olmat=beachmat::create_logical_output(nrow, ncol);
```

Equivalent methods are available for these matrix types.
For integer and logical matrices, `X` should be of type `Rcpp::IntegerVector::iterator` and `Rcpp::LogicalVector::iterator`, respectively, and `Y` should be an integer.

Currently, character output matrices are not supported.

## Important developer information

- Creation of a `HDF5Matrix` will perform a new `getHDF5DumpFile()` call with `for.use=TRUE` to obtain a new file name for storing the HDF5 output.
Similarly, the name of the data set is obtained via `getHDF5DumpName()`.
Both names are recorded in the dump log via `appendDatasetCreationToHDF5DumpLog()`.
This mimics the behaviour observed when `HDF5Matrix` instances are created at the R level.
- The API is not thread-safe, due to (i) the use of cached class members and (ii) the potential for race conditions when writing to the same location on disk/memory.
The first issue can be solved by using `clone` to create `*_output` copies for use in each thread.
However, each copy will still read from and write to the same disk/memory location.
It is the responsibility of the calling function to ensure that access is locked and unlocked appropriately across multiple threads.
(This may not be necessary if access does not overlap, e.g., writing to different rows.)

# Session information

```{r}
sessionInfo()
```
